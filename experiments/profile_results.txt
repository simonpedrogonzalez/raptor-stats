Timer unit: 1e-06 s

Total time: 2.95818 s
File: /media/simon/HDD/strix/repos/raptor-stats/raptorstats/api.py
Function: zonal_stats at line 9

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     9                                           @line_profiler.profile
    10                                           def zonal_stats(
    11                                                   vectors,
    12                                                   raster,
    13                                                   stats=None,
    14                                                   layer=0,
    15                                                   band=1,
    16                                                   nodata=None,
    17                                                   affine=None,
    18                                                   geojson_out=False,
    19                                                   prefix=None,
    20                                                   categorical=False,
    21                                                   **kwargs,
    22                                           ):
    23                                               """
    24                                               Zonal statistics using the Scanline rasterisation method.
    25                                           
    26                                               Parameters
    27                                               ----------
    28                                               vectors :  str | GeoDataFrame | anything GeoPandas can read
    29                                               raster  :  str | path-like | rasterio.DatasetReader
    30                                               stats   :  list[str]            statistics to compute (min, max, mean, etc.)
    31                                               layer   :  int | str            layer name/number for multi-layer vector sources
    32                                               band    :  int                  raster band (1-based)
    33                                               nodata  :  float | None         overrides raster NODATA value
    34                                               affine  :  affine.Affine | None required if `raster` is a NumPy array (not used here)
    35                                               geojson_out : bool              if True, return GeoJSON-like Features
    36                                               prefix  :  str | None           prefix every stat key (useful for merges)
    37                                           
    38                                               Returns
    39                                               -------
    40                                               list[dict]                      one stats-dict (or Feature) per input geometry
    41                                               """
    42                                           
    43                                               # ---- 1. prepare stats list (reuse rasterstats helper) ----
    44         1         75.3     75.3      0.0      stats_conf = Stats(stats, categorical=categorical)
    45                                           
    46                                               # ---- 2. read vectors (GeoPandas) ----
    47                                               
    48                                           
    49                                               # ---- 3. open raster once ----
    50         2       3968.2   1984.1      0.1      with open_raster(raster, affine=affine, nodata=nodata, band=band) as ds:
    51                                           
    52         1      17729.9  17729.9      0.6          gdf = open_vector(vectors, layer=layer, affine=affine)
    53                                           
    54                                                   # ---- 4. run Scanline ----
    55         1         25.0     25.0      0.0          sl = Scanline()
    56         1    2936378.1 2.94e+06     99.3          results = sl(ds, gdf, stats=stats_conf)   # Scanline.__call__ returns list[dict]
    57                                           
    58                                                   # ---- 5. attach / post-process ----
    59         1          2.3      2.3      0.0          if prefix:
    60                                                       results = [
    61                                                           {f"{prefix}{k}": v for k, v in res.items()} if res is not None else None
    62                                                           for res in results
    63                                                       ]
    64                                           
    65                                                   # if geojson_out:
    66                                                   #     features_out = []
    67                                                   #     for feat, res in zip(gdf.itertuples(index=False), results):
    68                                                   #         f = {
    69                                                   #             "type": "Feature",
    70                                                   #             "geometry": feat.geometry.__geo_interface__,
    71                                                   #             "properties": res or {},
    72                                                   #         }
    73                                                   #         features_out.append(f)
    74                                                   #     return features_out
    75         1          2.3      2.3      0.0          return results

Total time: 2.86629 s
File: /media/simon/HDD/strix/repos/raptor-stats/raptorstats/scanline.py
Function: Scanline._precomputations at line 19

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    19                                               @line_profiler.profile
    20                                               def _precomputations(self, features: gpd.GeoDataFrame, raster: rio.DatasetReader):
    21                                           
    22         1         13.4     13.4      0.0          transform = raster.transform
    23                                                   # ASSUMES NORTH UP, NO SHEAR AFFINE
    24                                                   # ASSUMES GEOMETRIES ARE POLYGONS OR MULTIPOLYGONS (NO POINTS, MULTIPOINTS, LINES)
    25                                           
    26         1          3.1      3.1      0.0          def rows_to_ys(rows):
    27                                                       return (transform * (0, rows + 0.5))[1]
    28                                           
    29                                                   # def rowcol_to_xy(rows, cols):
    30                                                   #     # coords of pixel centers
    31                                                   #     xs, ys = (transform * (cols + 0.5, rows + 0.5))
    32                                                   #     return xs, ys
    33                                           
    34                                                   # def ys_to_rows(ys):
    35                                                   #     return ((~transform) * (np.zeros_like(ys), ys))[1].astype(int)
    36                                           
    37         1          2.8      2.8      0.0          def xy_to_rowcol(xs, ys, left=True):
    38                                                       cols, rows = (~transform) * (xs, ys)
    39                                                       # if left:
    40                                                       #     # cols = np.ceil((xs - c) / a - 0.5).astype(int)
    41                                                       #     np.round(cols)
    42                                                       # else:
    43                                                       #     cols = np.floor((xs - c) / a - 0.5).astype(int)
    44                                                       return np.floor(rows).astype(int).clip(min=0), np.round(cols).astype(int).clip(min=0)
    45                                           
    46                                                   # def xy_to_rowcol(xs, ys):
    47                                                   #     # pixel in which the point is located
    48                                                   #     cols, rows = (~transform) * (xs, ys)
    49                                                   #     return np.floor(rows).astype(int), np.floor(cols).astype(int)
    50                                           
    51                                                   # c = transform.c
    52                                                   # a = transform.a
    53                                           
    54                                                   # def x_to_col_start(xs):
    55                                                   #     """First col whose centre is at or right of xs."""
    56                                                   #     return np.ceil((xs - c) / a - 0.5).astype(int)
    57                                           
    58                                                   # def x_to_col_end(xs):
    59                                                   #     """Last col whose centre is left of xs (inclusive)."""
    60                                                   #     return np.floor((xs - c) / a - 0.5).astype(int)
    61                                           
    62                                                   # get window for the entire features, that is, the bounding box for all features
    63                                                   # window = rio.windows.from_bounds(
    64                                                   #     *features.total_bounds,
    65                                                   #     transform=transform,
    66                                           
    67                                                   # )
    68                                                   # # snap to pixel grid
    69                                                   # window = window.round_offsets(op='floor').round_lengths(op='ceil')
    70                                           
    71         2      76646.6  38323.3      2.7          window = rio.features.geometry_window(
    72         1          0.5      0.5      0.0              raster,
    73         1         40.9     40.9      0.0              features.geometry,
    74                                                       # transform=transform,
    75         1          3.2      3.2      0.0              pad_x=0.5, pad_y=0.5,
    76                                                   )
    77                                           
    78                                                   # Debugging code
    79                                                   # w_height = int(np.ceil(window.height))
    80                                                   # w_width = int(np.ceil(window.width))
    81                                                   # global_mask = np.zeros((w_height+1, w_width), dtype=int)
    82                                                   # End Debugging code
    83                                           
    84         1         48.3     48.3      0.0          row_start, row_end = int(np.floor(window.row_off)), int(np.ceil(window.row_off + window.height))
    85         1          4.2      4.2      0.0          col_start, col_end = int(np.floor(window.col_off)), int(np.ceil(window.col_off + window.width))
    86                                           
    87         1         25.3     25.3      0.0          x0 = (raster.transform * (col_start - 1, 0))[0]
    88         1         11.5     11.5      0.0          x1 = (raster.transform * (col_end, 0))[0]
    89         1         10.6     10.6      0.0          all_rows = np.arange(row_start, row_end + 1)
    90         1         58.8     58.8      0.0          ys = rows_to_ys(all_rows)
    91                                           
    92         1         30.5     30.5      0.0          x0s = np.full_like(ys, x0, dtype=float)
    93         1         10.2     10.2      0.0          x1s = np.full_like(ys, x1, dtype=float)
    94                                           
    95                                                   # all points defining the scanlines
    96         3         60.4     20.1      0.0          all_points = np.stack([
    97         1         75.5     75.5      0.0              np.stack([x0s, ys], axis=1),
    98         1         34.2     34.2      0.0              np.stack([x1s, ys], axis=1)
    99         1          0.5      0.5      0.0          ], axis=1)
   100                                           
   101         1      60755.8  60755.8      2.1          scanlines = MultiLineString(list(all_points))
   102         1     192756.1 192756.1      6.7          all_intersections = scanlines.intersection(features.geometry)
   103                                           
   104         1          0.8      0.8      0.0          intersection_table = []
   105        50        984.0     19.7      0.0          for f_index, inter in enumerate(all_intersections):
   106        49        884.8     18.1      0.0              if inter.is_empty:
   107                                                           continue
   108        49         87.0      1.8      0.0              if isinstance(inter, MultiLineString):
   109        49        256.8      5.2      0.0                  geoms = inter.geoms
   110                                                       elif isinstance(inter, LineString):
   111                                                           geoms = [inter]
   112                                                       else:
   113                                                           raise TypeError(f"Unexpected intersection type: {type(inter)}")
   114                                           
   115     11497     220561.6     19.2      7.7              for ml in geoms:
   116                                                           # f_index, y, x0, x1, (space for row, col1,col2)
   117                                                           # coords = np.asarray(ml.coords)
   118     11448     507888.0     44.4     17.7                  x0, y_ = ml.coords[0]     # C-level direct index: one tuple, no loop
   119     11448     510027.2     44.6     17.8                  x1, _  = ml.coords[-1]
   120                                                           # y_ = coords[0][1]
   121                                                           # x0 = coords[0][0]
   122                                                           # x1 = coords[-1][0]
   123     22896      14040.9      0.6      0.5                  intersection_table.append((
   124     11448       6245.8      0.5      0.2                      f_index, y_, x0, x1
   125                                                           ))
   126                                           
   127         1          2.1      2.1      0.0          if not intersection_table:
   128                                                       self.results = [self.stats.from_array(np.ma.array([], mask=True)) for _ in features.geometry]
   129                                                       return
   130                                           
   131         1       5765.2   5765.2      0.2          intersection_table = np.array(intersection_table)
   132         1          4.7      4.7      0.0          inter_x0s = intersection_table[:, 2]
   133         1          1.0      1.0      0.0          inter_x1s = intersection_table[:, 3]
   134         1          1.1      1.1      0.0          inter_ys = intersection_table[:, 1]
   135         1          1.0      1.0      0.0          f_index = intersection_table[:, 0]
   136                                           
   137         1        403.6    403.6      0.0          rows, col0s = xy_to_rowcol(inter_x0s, inter_ys, left=True)
   138         1        234.2    234.2      0.0          _, col1s = xy_to_rowcol(inter_x1s, inter_ys, left=False)
   139                                                   # f = transform.f
   140                                                   # py = -transform.e # assumes north is up
   141                                                   # rows = np.ceil((f - inter_ys) / py - 0.5).astype(int)
   142                                                   # col0s = np.ceil((inter_x0s - c) / a - 0.5).astype(int)
   143                                                   # col1s = np.floor((inter_x1s - c) / a - 0.5).astype(int)
   144                                                   # col0s = x_to_col_start(inter_x0s)
   145                                                   # col1s = x_to_col_end(inter_x1s)
   146                                           
   147         4        218.9     54.7      0.0          reading_table = np.stack([
   148         1          2.1      2.1      0.0              rows, col0s, col1s, f_index
   149         2        156.9     78.4      0.0          ], axis=1).astype(int)
   150                                           
   151         1        212.6    212.6      0.0          reading_table = reading_table[col0s < col1s] # removes pixel reads where both intersections fall in between pixel centers
   152                                           
   153                                                   # sort by row
   154         1        506.0    506.0      0.0          reading_table = reading_table[np.argsort(reading_table[:, 0])]
   155         1        197.8    197.8      0.0          rows, row_starts = np.unique(reading_table[:, 0], return_index=True)
   156                                           
   157         1         19.7     19.7      0.0          pixel_values_per_feature = [[] for _ in range(len(all_intersections))]
   158                                           
   159      1215       1361.9      1.1      0.0          for i, row in enumerate(rows):
   160      1214       1228.1      1.0      0.0              start = row_starts[i]
   161      1214       1366.9      1.1      0.0              end = row_starts[i+1] if i+1 < len(row_starts) else len(reading_table)
   162      1214       1414.1      1.2      0.0              reading_line = reading_table[start:end]
   163                                           
   164      1214      31032.3     25.6      1.1              min_col = np.min(reading_line[:, 1])
   165      1214      18503.2     15.2      0.6              max_col = np.max(reading_line[:, 2])
   166      2428      17227.4      7.1      0.6              reading_window = rio.windows.Window(
   167      1214        689.0      0.6      0.0                  col_off=min_col,
   168      1214        610.1      0.5      0.0                  row_off=row,
   169      1214        835.6      0.7      0.0                  width=max_col - min_col,
   170      1214        628.3      0.5      0.0                  height=1
   171                                                       )
   172                                           
   173                                                       # Does not handle nodata
   174      1214     381973.2    314.6     13.3              data = raster.read(1, window=reading_window, masked=True)
   175      1214       2841.5      2.3      0.1              if data.shape[0] == 0:
   176                                                           continue
   177      1214      65158.0     53.7      2.3              data = data[0]
   178                                           
   179     12600      39318.5      3.1      1.4              for j, col0, col1, f_index in reading_line:
   180                                           
   181     11386       7861.4      0.7      0.3                  c0 = col0 - min_col
   182     11386       6615.7      0.6      0.2                  c1 = col1 - min_col
   183     11386     578074.0     50.8     20.2                  pixel_values = data[c0:c1]
   184                                           
   185                                                           # Debugging code
   186                                                           # mark the pixels in the global mask
   187                                                           # row_in_mask = row - row_start
   188                                                           # col0_in_mask = col0 - col_start
   189                                                           # col1_in_mask = col1 - col_start
   190                                                           # global_mask[row_in_mask, col0_in_mask:col1_in_mask] = f_index + 1
   191                                                           # End Debugging code
   192                                           
   193     11386       8246.6      0.7      0.3                  if len(pixel_values) > 0:
   194     11386       9495.0      0.8      0.3                      pixel_values_per_feature[f_index].append(pixel_values)
   195                                           
   196                                           
   197                                                   # combine the results
   198         1          0.7      0.7      0.0          results_per_feature = []
   199        50         31.2      0.6      0.0          for i in range(len(pixel_values_per_feature)):
   200        49         34.4      0.7      0.0              if not pixel_values_per_feature[i]:
   201                                                           feature_data = np.ma.array([], mask=True)
   202                                                       else:
   203        49      87930.1   1794.5      3.1                  feature_data = np.ma.concatenate(pixel_values_per_feature[i])
   204                                                       # get the stats
   205        49       4473.8     91.3      0.2              r = self.stats.from_array(feature_data)
   206        49         37.4      0.8      0.0              results_per_feature.append(r)
   207                                           
   208         1          5.9      5.9      0.0          self.results = results_per_feature
   209                                           
   210                                                   # Debugging code
   211                                                   # global_mask = global_mask[:-1, :]  # remove the last row added for debugging
   212                                                   # ref_mask = ref_mask_rasterstats(features, raster, window)
   213                                                   # compare_stats(self.results,
   214                                                   #     self.raster_file_path.files[0], features.attrs.get('file_path'), stats=self.stats, show_diff=True, precision=5)
   215                                           
   216                                                   # plot_mask_comparison(global_mask, ref_mask, features, raster.transform, window=window, scanlines=inter_ys)
   217                                                   # print('done')
   218                                                   # end of debugging code

